# Euler Problem 29:
# Consider all integer combinations of a^b for 2<=a<=5 and 2<=b<=5:
#
#       2^2=4, 2^3=8, 2^4=16, 2^5=32
#       3^2=9, 3^3=27, 3^4=81, 3^5=243
#       4^2=16, 4^3=64, 4^4=256, 4^5=1024
#       5^2=25, 5^3=125, 5^4=625, 5^5=3125
#
# If they are placed in numerical order, with any repeats removed, we get the
# following sequence of 15 distinct terms:
#       4,8,9,16,25,27,32,64,81,125,243,256,625,1024,3125
#
# How many distinct terms are in the sequence generated by a^b for 2<=a<=100
# and 2<=b<=100?

# Solution
# -----------------------------------------------

# I'd first like to take a brief second to note that some people might point
# out that this problem is brute forceable in the case n=100. That's correct...
# It doesn't take super long to weave through the 100x100=10000 entries and
# unique/ form the set. HOWEVER my interest isn't in one instance of a problem/
# one case but rather what solutions work best as the problem grows (both
# time/clock cycle/FLOP analysis as well as the memory analysis). Anyone who
# knows a thing or two about complexity would realize that you don't want to
# calculating a^b for even modestly large a and b, much less creating
# datastructures with those gigantic numbers (will reach over flow before too
# long) and then uniquing/ whatever datastructure you choose to get the
# cardinality of the set.

# Therefore, for most of these problems instead of solving for a particular
# sized problem I try to implement solutions that are more robust/ can
# generalize to much more intensive computational cases. This is great because
# instead of going with the "You can simply brute force that" kind of attitude
# you usually have to investigate and take a second to look at the math,
# whether it's basic number theory, or numerical methods, or whatever before
# you implement the algorithm!

# Let's write out the 2<=x,y<=10 case seeing if we can pick up the pattern as
# we go (also see if there's a function that generates the number of distinct
# terms with increasing n (unlikely I think)):
#
# 2^2=4    2^3=8     2^4=16      2^5=32     2^6=64       2^7=128       2^8=256        2^9=512          2^10=1024
# 3^2=9    3^3=27    3^4=81      3^5=243    3^6=729      3^7=2187      3^8=6561       3^9=19683        3^10=59049
# 4^2=16   4^3=64    4^4=256     4^5=1024   4^6=4096     4^7=16384     4^8=65536      4^9=262144       4^10=1048576
# 5^2=25   5^3=125   5^4=625     5^5=3125   5^6=15625    5^7=78125     5^8=390625     5^9=1953125      5^10=9765625
# 6^2=36   6^3=216   6^4=1296    6^5=7776   6^6=46656    6^7=279936    6^8=1679616    6^9=10077696     6^10=60466176
# 7^2=49   7^3=343   7^4=2401    7^5=16807  7^6=117649   7^7=823543    7^8=5764801    7^9=40353607     7^10=282475249
# 8^2=64   8^3=512   8^4=4096    8^5=32768  8^6=262144   8^7=2097152   8^8=16777216   8^9=134217728    8^10=1073741824
# 9^2=81   9^3=729   9^4=6561    9^5=59049  9^6=531441   9^7=4782969   9^8=43046721   9^9=387420489    9^10=3486784401
# 10^2=100 10^3=1000 10^4=10000 10^5=100000 10^6=1000000 10^7=10000000 10^8=100000000 10^9 =1000000000 10^10=10000000000

# Wow, I can't believe I just went through that exercise, anyways, let's
# rewrite the above matrix in a more appropriate notation (all exponential
# notations for each entry):

# 2^2  2^3  2^4=4^2    2^5  2^6=4^3=8^2       2^7  2^8=4^4=16^2       2^9=8^3     2^10=4^5
# 3^2  3^3  3^4=9^2    3^5  3^6=9^3=27^2      3^7  3^8=9^4=81^2       3^9=27^3    3^10=9^5
# 4^2  4^3  4^4=16^2   4^5  4^6=16^3=64^2     4^7  4^8=16^4=256^2     4^9=64^3    4^10=16^5
# 5^2  5^3  5^4=25^2   5^5  5^6=25^3=125^2    5^7  5^8=25^4=635^2     5^9=125^3   5^10=25^5
# 6^2  6^3  6^4=36^2   6^5  6^6=36^3=216^2    6^7  6^8=36^4=1296^2    6^9=216^3   6^10=36^5
# 7^2  7^3  7^4=49^2   7^5  7^6=49^3=343^2    7^7  7^8=49^4=2401^2    7^9=343^3   7^10=49^5
# 8^2  8^3  8^4=64^2   8^5  8^6=64^3=513^2    8^7  8^8=64^4=4096^2    8^9=513^3   8^10=64^5
# 9^2  9^3  9^4=81^2   9^5  9^6=81^3=729^2    9^7  9^8=81^4=6561^2    9^9=729^3   9^10=81^5
# 10^2 10^3 10^4=100^2 10^5 10^6=100^3=1000^2 10^7 10^8=100^4=10000^2 10^9=1000^3 10^10=100^5

# Now you may point out that we only went one direction here, only reducing the
# exponent down when possible and not ever factoring down the base. This is
# reasonable to do because once we find all the equivalences from the smallest
# base there's no reason to recalc them at higher bases.

# So now we observe that any exponents that are have divisors can all be
# refactored to a new base and a divided exponent until it's prime. A decent
# strategy is to create a set of two-tuples then weave through the entries,
# eliminating all the equivalent entries in place

import math as M
from sets import Set
import time as T

# Helper function, finds all divisors of a number, return a set
def divisors(n):
    lst=[]
    for i in range(2,int(M.sqrt(n))):
        if n%i == 0:
            lst.append(i)
            lst.append(int(n/i))
   # if n%M.sqrt(n) == 0:
   #     lst.append(int(M.sqrt(n)))
    print lst
    return lst


def distinctPowers(n):
    #create the two tuple set
    basePowerSet=[]
    rptEntries=Set([])
    for i in range(2,n+1):
        for j in range(2,n+1):
            basePowerSet.append((i,j))

    for k in basePowerSet:
        (base,power)=k
        print k
        print "the divisors of the power are", divisors(power)
        for i in divisors(power):
            print i, "is a divisor of the exponent"
            if base**(power/i)<=n:
                print "does not put the base over",n,"therefore adding",((base**(power/i),power/i)), "to the repeat list"
                rptEntries.add((base**(power/i),power/i))
# Would like to know of a way to do this in place but not easy since we're
# iterating over the set already and removing from it
    print rptEntries
    print "There are", (n-1)**2-len(rptEntries), "unique entries"


# Just playing around with some speed tests, List is about 3 to 4 times faster
# than Set so we'll keep th initial tuple as a list
def mkSet(n):
    st=T.time()
    a=Set([])
    for i in range(n+1):
        a.add(i)
    ft=T.time()-st
    print "Set took:",ft

def mkLst(n):
    st=T.time()
    a=[]
    for i in range(n+1):
        a.append(i)
    ft=T.time()-st
    print "List took",ft


if __name__=="__main__":
    import sys
    #distinctPowers(int(sys.argv[1]))
    divisors(int(sys.argv[1]))
    #For speed testing between Set and list for my curiosity
    #mkSet(int(sys.argv[1]))
    #mkLst(int(sys.argv[1]))


